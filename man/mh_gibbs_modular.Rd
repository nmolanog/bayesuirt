% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesuirt.R
\name{mh_gibbs_modular}
\alias{mh_gibbs_modular}
\title{mh_gibbs_modular Function}
\usage{
mh_gibbs_modular(dat, idname, psi0, theta0, B = NULL, b = NULL, grad.fix,
  grad.mix, nlf, inv_link, hprim, Nc = 10000)
}
\arguments{
\item{dat}{a data frame containing test info. rows for individuals and columns for items. aditionally, a variable which identify individuals must be supied.}

\item{idname}{atomic character giving the name of the id variable in dat.}

\item{psi0}{a vector of initial values for parameter psi0. See nlf_2pl documentation.}

\item{theta0}{vector of initial values for latent traits. See nlf_2pl documentation.}

\item{B}{Prior covariance matrix for psi.}

\item{b}{Prior expected values for psi.}

\item{grad.fix}{gradient function of fixed effects}

\item{grad.mix}{gradient function of random effects}

\item{nlf}{nonlinear function}

\item{inv_link}{inverse of link function}

\item{hprim}{derivative of link function}

\item{Nc}{number of mcmc iterations.}
}
\value{
a list with the following objects:
\itemize{
  \item fixp: a matrix where each row corresponds to an mcmc simulation of psi parameters.
  \item theta: a matrix where each row corresponds to an mcmc simulation of latent traits.
  \item Dev: a vector where deviance is calculated for each mcmc iteration.
  \item B: Prior covariance matrix used for psi.
  \item b: Prior Expected values used for psi.
}
}
\description{
this functions implements the metropolis-hastings within gibbs algorithm proposed in molano thesis for a given model.
}
\examples{
###Simulate a data set with model m1 of Yuli
nitems<-7
nind<-100
sort(alpha_o<-rnorm(nitems))
sort(beta_o<-rnorm(nitems))
summary(theta_o<-rnorm(nind))

temp.b<-matrix(beta_o,ncol=nitems,nrow=nind, byrow =T)
temp.a<-matrix(alpha_o,ncol=nitems,nrow=nind, byrow =T)
temp.t<-matrix(theta_o,ncol=nitems,nrow=nind)
logit_expt_theta_M<-exp(temp.t)/(1+exp(temp.t))
exp_alpha_M<-exp(temp.a)
exp_beta_M<-exp(temp.b)
### m1 model of yuli
pmod<-1-(1-(logit_expt_theta_M)^(exp_alpha_M))^(exp_beta_M)

summary(pmod)
test<-data.frame(ifelse(runif(nitems*nind)<pmod,1,0))
colnames(test)<-paste("t",1:nitems,sep="")
test\%>\%{apply(., 1,sum)/nitems} \%>\%summary
test\%>\%apply( 2,sum)/nind
test<-data.frame(test,id=1:nind)

###non linear function
nlf_m1<-function(X,psi,z,theta,nitems){
 logit_zt<-exp(z\%*\%theta)/(1+exp(z\%*\%theta))
 exp_xa<-exp(X\%*\%psi[(nitems+1):(2*nitems)])
 exp_xb<-exp(X\%*\%psi[1:nitems])
 return(drop(1-(1-(logit_zt)^(exp_xa))^(exp_xb)))
 }
 ###inverse link
 inv_link_m1<-function(x){x}
 ###fixed effects gradient
 grad.fix_m1<-function(X,psi,z,theta,nitems){
   logit_zt<-exp(z\%*\%theta)/(1+exp(z\%*\%theta))
   exp_xa<-exp(X\%*\%psi[(nitems+1):(2*nitems)])
   exp_xb<-exp(X\%*\%psi[1:nitems])
   logitzt_high_expa<-logit_zt^(exp_xa)
   a_grad<-drop(exp_xa*exp_xb*(logitzt_high_expa)*log(logit_zt)*((1-logitzt_high_expa)^(exp_xb-1)))*X
   b_grad<- drop(-exp_xb*log(1-(logitzt_high_expa))*((1-(logit_zt^exp_xa))^(exp_xb)))*X
   return(cbind(b_grad,a_grad))
 }
 ###random effects gradient
 grad.mix_m1<-function(X,psi,z,theta,nitems){
   logit_zt<-exp(z\%*\%theta)/(1+exp(z\%*\%theta))
   exp_xa<-exp(X\%*\%psi[(nitems+1):(2*nitems)])
   exp_xb<-exp(X\%*\%psi[1:nitems])
   logitzt_high_expa<-logit_zt^(exp_xa)
   return(drop(exp_xa*exp_xb*logitzt_high_expa*((1-logitzt_high_expa)^(exp_xb-1))*(1-logit_zt))*z)
 }

 ### derivative of link
 hprim_m1<-function(x){rep(1,length(x))}

 bres<-mh_gibbs_modular(test,"id",psi0=c(beta_o,alpha_o),theta0=theta_o,B=NULL,b=NULL,
grad.fix=grad.fix_m1,grad.mix=grad.mix_m1,nlf=nlf_m1,inv_link=inv_link_m1,
hprim=hprim_m1,Nc=10000)
}
\keyword{a}
\keyword{double}
\keyword{vector}
